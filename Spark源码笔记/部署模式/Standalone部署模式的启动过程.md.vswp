vnote_backup_file_826537664 E:/SourceInsight/SparkSourceCodeLearning/Spark源码笔记/部署模式/Standalone部署模式的启动过程.md
# Standalone部署模式的启动过程

![](_v_images/_1574219424_31522.png)

* ①Standalone部署模式中首先会启动一到多个Master.main函数的进程。每个Master.main进程中都会创建Master实例并注册到Master自己的RpcEnv中，在启动Master实例的过程中会创建ZooKeeperLeaderElectionAgent实例。

* ②每个Master实例对应的ZooKeeperLeaderElectionAgent实例都会参与Zookeeper的领导选举，最终确定正式的领导这并调用ZooKeeperLeaderElectionAgent的isLeader方法。isLeader方法将会调用Master的electedLeader方法将Master选举为领导，Master的状态被设置为激活。对于没有被选举为领导的Master，会调用ZooKeeperLeaderElectionAgent的notLeader方法。notLeader方法会将领导者的信息告诉支持者。

* ③Standalone部署模式中会启动一到多个Worker.main函数的进程。每个Worker.main进程中都会创建Worker实例并注册到Worker自己的RpcEnv中，在启动Worker实例的过程中会向Master实例发送RegisterWorker消息。

* ④Master接收到RegisterWorker消息后对WorkerInfo进行注册。WorkerInfo注册成功后，Master向Worker回复RegisteredWorker消息。Worker收到RegisteredWorker消息后，将向Master发送WorkerLatestState消息，以便把Worker的最新状态汇报给Master。 Master接收到WorkerLatestState消息后，将对Executor和Driver进行匹配，对于不匹配的Executor 和 Driver, 将通知Worker“杀死”

* ⑤SparkContext创建完TaskSchedulerImpl后， 将启动TaskSchedulerImpl。TaskSchedulerImpl的start方法一开始将会调用StandaloneSchedulerBackend的start方法。

* ⑥StandaloneSchedulerBackend的start方法中会创建并启动StandaloneAppClient。

* ⑦StandaloneAppClient的start方法创建ClientEndpoint并将ClientEndpoint注册到SparkContext的SparkEnv的RpcEnv中，进而引起ClientEndpoint的启动。

* ⑧ClientEndpoint在启动时会向每个Master发送RegisterApplication消息。

* ⑨Master收到RegisterApplication消息并注册成功后， 会向DriverEndpoint发送RegisteredApplication消息。ClientEndpoint的receive方法接收到RegisteredApplication消息后， 更新ClientEndpoint的appId、registered、master 属性及 StandaloneSchedulerBackend的APPId属性。











